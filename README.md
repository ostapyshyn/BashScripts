# BashScripts


<details>
<summary>Install Java</summary>
<br />

Write a bash script using any editor that installs the latest java version and checks whether java was installed successfully by executing a `java -version` command.

After installation command, it checks 3 conditions:

  1. whether java is installed at all
  2. whether an older Java version is installed (java version lower than 11)
  3. whether a java version of 11 or higher was installed 

It prints relevant informative messages for all 3 conditions. Installation was successful if the 3rd condition is met and you have Java version 11 or higher available.

-----

**script:**
```sh
#!/bin/bash

function installation_needed {
  java_version=$(java -version 2>&1 >/dev/null | grep "java version\|openjdk version" | awk '{print $3}')
  java_version_short=$(java -version 2>&1 >/dev/null | grep "java version\|openjdk version" | awk '{print substr($3,2,2)}')

  if [[ "$java_version" = "" ]]
  then
    echo "No java installation found."
    return 1
  elif [[ "$java_version_short" = "1." ]]
  then
    echo "Old java version $java_version found."
    return 1
  elif [[ "$java_version_short" -ge 11 ]]
  then
    echo "Java version $java_version found."
    return 0
  fi
}

function install_java {
  echo "Installing current JDK..."
  apt-get update
  apt-get install -y default-jre
}

function check_installation {
  installation_needed
  if [[ $? -eq 0 ]]
  then
    echo "The new java version >= 11 was successfully installed."
  else
    echo "The new Java version >= 11 could NOT be installed!"
  fi
}

function main {
  installation_needed
  if [[ $? -eq 1 ]]
  then
    install_java
    check_installation
  else
    echo "Java with version greater or equal 11 is already installed."
  fi
}

main

```

Execute script with sudo!
```sh
touch install_java.sh
code ~/install_java.sh
chmod u+x script.sh
./script.sh    
```
Breakdown of command that gets java version:
- `java -version` gives you the complete version output.
- `> /dev/null 2>&1` addition does following things: `>` redirects the output of `java -version` command to a file `/dev/null`, which is a special type of file, that accepts and discards all input written to it, and with `2>&1`, even the error output of the `java -version` command will be discarded by `/dev/null` file. So described together, this option takes the output, including any errors generated by the `java -version` command and discards it, not showing it on the command-line and silently forwarding it using `|` (pipe) to the next command, which is `grep "java version\|openjdk version"`
- `grep "java version\|openjdk version"` simply finds a line in the output that has "java version" or "openjdk version" in it. The example line will look like this: openjdk version "11.0.16" 2022-07-19
- `awk '{print substr($3,2,2)}` takes the line from the previous output and grabs the third section of the string "11.0.16" and from there grabs the first 2 characters, which will be "11"


*Detailed explanation of `2>&1`:

Every time, we execute a program or a command, operating system opens three files: **standard input**, **standard output**, and **standard error**, and each file gets a file descriptor integer from the OS: 0, 1, and 2, respectively. So 2>&1 simply says redirect standard error (2) to standard output (1). The `&` before `1` in this case, means whatever follows is a file descriptor, not a filename. 

Explanation of `if else` script:
- In the if else checks, we check if the $java_version variable has no value at all or empty value, it means we have no java installation at all
- If you have an older version of java already installed, like 1.6, 1.7, 1.8, then the value of `"$java_version"` will be `"1."` - first 2 characters. So with `"$java_version" == "1."`, we check whether `java_version` variable is `"1."`. This means installing latest java version was not successful, since you still have only the old version.
- In case of success you should get java version which is 11 or higher (`"$java_version" -ge 11`), which will print success message.

</details>
<details>
<summary>User Processes</summary>
 <br />

- Write a bash script using any editor that checks all the processes running for the current user (USER env var) and prints out the processes in console.
Hint: use `ps aux` command and grep for the user.
- Extend the previous script to ask for a user input for sorting the processes output either by memory or CPU consumption, and print the sorted list.
- Extend the previous script to ask additionally for user input about how many processes to print. Hint: use `head` program to limit the number of outputs.Â 

-----

**script:**
```sh
#!/bin/bash

echo -n "Would you like to sort the processes output by memory or CPU? (m/c) "
read sortby
echo -n "How many results do you want to display? "
read lines

if [ "$sortby" = "m" ]
then
    ps aux --sort -%mem | grep "PID\|`whoami`" | head -n "$lines"
elif [ "$sortby" = "c" ]
then
    ps aux --sort -%cpu | grep -i "PID\|$USER" | head -n "$lines"
else
    echo "No input provided. Exiting"
fi
```

`echo -n`: -n: do not output the trailing newline
`ps aux --sort -%cpu`: sort by cpu utilization of the process in "##.#" format.  Currently, it is the CPU time used divided by the time the process has been running (cputime/realtime ratio), expressed as a percentage.
`ps aux --sort -%mem`: sort by ratio of the process's resident set size to the physical memory on the machine, expressed as a percentage
`ps aux --sort -rss`: sort by resident set size, the non-swapped physical memory that a task has used (in kilobytes)

</details>

<details>
<summary>User Processes</summary>
 <br />

- Write a bash script that helps to automate.


-----

**script:**
```sh
#!/bin/bash

help() {
  echo "
  Usage:
    ./application init - init working directory and database
    ./application clean - clean working directory and stop database
    ./application build - run JUnit tests to check app health (-skipTests arg to skip tests) and build jar
    ./application up - launch the application
  "
}

case $1 in
help)
  help
  ;;
init)
  init
  ;;
clean)
  clean
  ;;
build)
  build $2
  ;;
up)
  up
  ;;
*)
  echo "$1 command is not valid"
  exit 1
  ;;
esac
```

`echo -n`: -n: do not output the trailing newline
`ps aux --sort -%cpu`: sort by cpu utilization of the process in "##.#" format.  Currently, it is the CPU time used divided by the time the process has been running (cputime/realtime ratio), expressed as a percentage.
`ps aux --sort -%mem`: sort by ratio of the process's resident set size to the physical memory on the machine, expressed as a percentage
`ps aux --sort -rss`: sort by resident set size, the non-swapped physical memory that a task has used (in kilobytes)

</details>

-----
